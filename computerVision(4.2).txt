#SEED lab mini project -- computer vision
#Group 8 - zoe logan


#takes a picture, locates any aruco markers, and determines which quadrant
#the aruco marker is in in order to rotate the wheel to the correct direction


#import necessary libraries
import numpy as np
import cv2 as cv
from picamera import PiCamera
import math


camera = PiCamera()
cam = np.array([[ 534, 0, 341],
 [0, 534, 233],[0, 0, 1]])
dist = np.array([-2.94138985e-01, 1.22538100e-01, 1.28531080e-03, -2.57140954e-04, 1.35279717e-02])
focal = cam[0,0]


#get gains of camera to behave better in lighting
cam_gain = camera.awb_gains
camera.awb_mode = 'off' #turn off auto white balanec
camera.awb_gains = cam_gain #set to manual data given by gains earlier


def camera_quadrant_finder():
    i = 0 #used for however many times necessary to take images
    quadrant = 0 #will equal 0,1,2,3
    radian = 0 #equal the value to print to the lcd


    while(i < 1): #set i< for desired number of images
        camera.capture("%d.jpg" % i)
        img = cv.imread("%d.jpg" % i)
        cv.imshow("img", i)
        gray_img = cv.cvtColor(img, cv.COLOR_BGR2GRAY)#convert to grayscale
        cv.imshow('gray img', gray_img)
        cv.waitKey(0)
        cv.destroyAllWindows()
    
        #print("here")
        dictionary = cv.aruco.getPredefinedDictionary(cv.aruco.DICT_6X6_250)
        parameters = cv.aruco.DetectorParameters_create()
        #detect markers
        corners,ids,rejectedImgPoints = cv.aruco.detectMarkers(gray_img, dictionary, parameters = parameters)


        if(ids != None):
            print(ids)
            h, w = gray_img.shape #determine size of image to find quadrants
            mid_h = h/2
            mid_w = w/2 #image midpoints
            print("mid height:", mid_h)
            print("mid width:", mid_w)


            #find center of aruco marker
            for corner in corners:
                center_x = (corner[0][0][0] + corner[0][1][0] + corner[0][2][0] + corner[0][3][0]) / 4
                center_y = (corner[0][0][1] + corner[0][1][1] + corner[0][2][1] + corner[0][3][1]) / 4
            print("center x:", center_x)
            print("center y:", center_y)
            #4 quadrants: starting at 0 in top right and moving CW
            #0: y > mid_h and x > mid_w (3pi/2)
            #1: < mid_h and > mid_w (0)
            #2: < mid_h and < mid_w (pi/2)
            #3: > mid_h and < mid_w (pi)


            #check to see which quadrant marker falls into and print/return
            if(center_y < mid_h) and (center_x > mid_w):
                quadrant = 0
                radian = '3pi/2 - 2pi'
                print(quadrant, " : ", radian)
                print("top right")
            if(center_y > mid_h) and (center_x > mid_w):
                quadrant = 1
                radian = '0 - pi/2'
                print("bottom right")
                print(quadrant, " : ", radian)
            if(center_y > mid_h) and (center_x < mid_w):
                quadrant = 2
                radian = 'pi/2 - pi'
                print("bottom left")
                print(quadrant, " : ", radian)
            if(center_y < mid_h) and (center_x < mid_w):
                quadrant = 3
                radian = 'pi - 3pi/2'
                print("top left")
                print(quadrant, " : ", radian)  
            
        else:
            print("No markers found")


        i = i + 1


    return(quadrant)#return the quadrant value to be returned to the LCD/motor




#test to make sure everything works
camera_quadrant_finder()